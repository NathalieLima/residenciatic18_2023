# EXEMPLO PROFESSOR ALUNO-BANCODEDADOS

obter_opcao()
monta_menu(menu, "Escolha uma opcao")

-> exit()

-> fzr atvds de exemplos

- criar funçoes q vao poder ser reaproveitadas

- cls

-> puxar e salvar dinamicamente, pra nn ter que carregar e recarregar o arquivo inteiro a cada alteração

- tasks.json pra mudar os argumentos

conio.h: console input e output
getch, getche

### criar objetos dinamicamente

crio na hora que eu quiser e mato na hora q eu qsr tb
ja estaticamrnte ele vai durar ao longo da execução do seu bloco

-> como criar arquivo de biblioteca, obj: "move esses arquivos obj pra biblioteca, extensao lib ou l"

- documentaçao microsoft
- abertura de arquivos c++









# SLIDE 24 

agregado pode existir por conta propria, n tem dependencia tao grande
composicaçao vc é composto, n há separação

### agregação

- passar por referencia vai manter a composiçao/agregaçao

criarum atributo que é objeto da outra classe
1 pra muitos: vector

vetor e dependencia, e jogado dentro do vetor

no engenheiro os projetos que ele participou
e nos projetos os engenheiros que participaram

### diagrama de situaçao

->alocaçao dinamica

linha tracejada é a linha da vida. se tiver X é pq o objeto deixou de existir
a linha reta [e te,ṕ de ativação: tempo que a funçao tá ativada

- autochamada

:Aluno        = objeto da classe ALuno
ou aluno:Aluno = objeto chamado aluno que é da classe Turma
sublinhar assegura que é um objeto
- smp especificar a classe dele


criar casos de uso
ex: cadastrar cliente. dentro dele, fazer diagrama de sequencia pra ele; as trocas de mensagem pra conseguir completar aquele caso

feito isso, diagrama de classe pra aquele caos
colocar metodos identificando no diagrama de sequencia

pra cadastrar cliente tenho construtor


no final pegar essas classes parciais
em um diagrama de classe total, com todos os metodos e atributos

e fzr relacionamentos identificados ao longo dos diagramas de sequencia

cada pagina tem 1 diagrama de classe
diagrama c nomes das classes e mostrar relacionamento
seno a coisa fica impossivel

todos eles separados pra cada caso de uso, e vejo cada um

n vai implementar tudo de vez, vai fazendo caso de uso pra caso de uso

vai documentando junto com a implementaçao
isso é bom pq vc n precisa esperar a documentaçao ficar todo completo pra começar a codar; entao o cliente n precisaria esperar um ano pra ver resultado
pode ir mostrando o sistema funcionando aos poucos

metodos ageis
ser coisa rapida, mapear
-> UML
nos metodos ageis a ideia é partir logo pra codificaçao, mas é preciso ter uma base, um planejamento